<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
	<title>Wolframe: Wolframe, a modular, 3-tier application server written in C++</title>
	<meta name="generator" content="Doxygen 1.8.7"/>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
	<link href="/layout/styles/main.css" rel="stylesheet" type="text/css" media="all" />
	<link href="/layout/styles/mediaqueries.css" rel="stylesheet" type="text/css" media="all" />
	<!--[if lt IE 9]>
		<link href="/layout/styles/ie/ie8.css" rel="stylesheet" type="text/css" media="all" />
		<script src="/layout/scripts/ie/css3-mediaqueries.min.js"></script>
		<script src="/layout/scripts/ie/html5shiv.min.js"></script>
	<![endif]-->
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="stylesheet-doxygen-webpage.css" rel="stylesheet" type="text/css" />
</head>
<body class="">
<div class="wrapper row1">
	<header id="header" class="full_width clear">
		<div id="header-logo">
			<h1><a href="/index.html">Project Wolframe</a></h1>
			<h2>The Straight Path to Successful Projects</h2>
		</div>
		<div id="header-search">
			<form id="cse-search-box" action="http://www.wolframe.net/gsearch.html">
				<input type="hidden" name="cx" value="007231504736047898702:wrnjvfljzvu" />
				<input type="hidden" name="ie" value="UTF-8" />
				<input type="text" name="q" size="31" />
<!--				<input type="submit" name="sa" value="&#xf002;" /> -->
				<input type="submit" name="sa" class="search-bttn" value="" />
			</form>
		</div>
	</header>
</div>
<!-- ################################################################################################ -->
<div class="wrapper row2">
	<nav id="topnav">
		<ul class="clear">
<!-- BEGIN MENU -->
			<li><a href="/index.html" title="Home">Home</a></li>
			<li><a href="/downloads.html" title="Downloads">Downloads</a></li>
			<li class="active"><a href="/documentation.html" title="Documentation">Documentation</a></li>
			<li><a class="drop" href="/support.html" title="Support">Support</a>
				<ul>
					<li><a href="/faqs.html" title="FAQ">FAQ</a></li>
					<li><a href="http://sourceforge.net/p/wolframe/mailman/" title="Mailing lists">Mailing lists</a></li>
				</ul>
			</li>
			<li class="last-child"><a href="/contact.html" title="Contact Us">Contact Us</a></li>
<!-- END MENU -->
		</ul>
	</nav>
</div>
<!-- ################################################################################################ -->
<!-- ################################################################################################ -->
<!-- content -->
<div class="wrapper row3">
	<div id="container">
		<h2>Wolframe, 0.0.3</h2>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!--</div> /top, this will be generated by doxygen later on! -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Wolframe, a modular, 3-tier application server written in C++ </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="ModuleTypes"></a>
Writing modules for Wolframe</h1>
<h2><a class="anchor" id="ModuleTypeIntro"></a>
Introduction</h2>
<p>In Wolframe we can write modules for extending our application. Modules are units that export objects that can be used as components. The main source file of the module contains the following code block that declares the objects to be exported by the module. For using the macros shown in the following examples, we have to include the file <a class="el" href="appDevel_8hpp.html">include/appDevel.hpp</a> or the sub-include files needed. </p><div class="fragment"><div class="line"><a class="code" href="moduleFrameMacros_8hpp.html#a5c94abd61d1619c761279522e203a4a4">WF_MODULE_BEGIN</a>( <span class="stringliteral">&quot;MyModule&quot;</span>, <span class="stringliteral">&quot;this text is a short, one line description of the module&quot;</span>)</div>
<div class="line"> <span class="comment">// ... here we declare the components to export</span></div>
<div class="line"><a class="code" href="moduleFrameMacros_8hpp.html#ad59c3d56591ee809897499a5d99bcd04">WF_MODULE_END</a></div>
</div><!-- fragment --> <h2><a class="anchor" id="ModuleObjTypeList"></a>
Module component types</h2>
<ul>
<li><b>Command</b> <b>handler:</b> A command handler (<a class="el" href="class__Wolframe_1_1cmdbind_1_1CommandHandler.html" title="Command handler interface. ">_Wolframe::cmdbind::CommandHandler</a>) implements a sub part of the client server protocol. They are declared in the section Processor of the main configuration. Currently there exist only two types of command handlers loadable from modules:<ul>
<li>the standard command handler also called direct map. The standard command handler delegates the requests to functions to execute. It uses the filter modules to get an iterator on the input to pass to functions to execute. It uses forms declared to validate input and output.</li>
<li>the lua command handler</li>
</ul>
See <a class="el" href="CommandHandlerModule.html">Command handler module</a>. A real example can be found in src/modules/cmdbind/directmap/.</li>
<li><b>Document</b> <b>type</b> <b>detection:</b> We need for each document format processed a document type detection (<a class="el" href="class__Wolframe_1_1cmdbind_1_1DoctypeDetector.html" title="Interface to document type and format detection. ">_Wolframe::cmdbind::DoctypeDetector</a>) that extracts the document type information (<a class="el" href="class__Wolframe_1_1types_1_1DoctypeInfo.html" title="Document type information representation created by a document type recognizer. ">_Wolframe::types::DoctypeInfo</a>). This info structure is needed by command handlers to associate a document with a function to execute. Currently there are two document type detection modules implemented:<ul>
<li>XML</li>
<li>JSON</li>
</ul>
See <a class="el" href="DoctypeDetectionModule.html">Document type detection module</a>.</li>
<li><b>Filter</b> <b>type:</b> Filters (<a class="el" href="class__Wolframe_1_1langbind_1_1Filter.html" title="Structure defining a filter for input and output as unit. ">_Wolframe::langbind::Filter</a>) are used to parse a document and to create a unified representation for processing it and contrarywise map the unified representation to a document. Hence a filter consist of two parts, an input filter (<a class="el" href="class__Wolframe_1_1langbind_1_1InputFilter.html" title="Input filter. ">_Wolframe::langbind::InputFilter</a>) and an output filter (<a class="el" href="class__Wolframe_1_1langbind_1_1OutputFilter.html" title="Output filter. ">_Wolframe::langbind::OutputFilter</a>). The unified representation for filters is a structure with the document meta data as key/value pairs and a sequence of content elements of the following types:<ul>
<li>OpenTag: Open a substructure. The value is the name of the structure opened or if empty, defining a new array element</li>
<li>CloseTag: Close a substructure or an array element or it is marking the end of content (final close)</li>
<li>Value: Defines an atomic element</li>
<li>Attribute: Defines an attribute name, the following element is the attribute value (as type value).</li>
</ul>
Filters define flags (<a class="el" href="class__Wolframe_1_1langbind_1_1FilterBase.html#a38fc65e847310d5c4e3a7bdb64f7f138">_Wolframe::langbind::FilterBase::Flags</a>) to level out language differences between producer and consumer of the filter element sequence. The initialization of the flags define a contract between producer and consumer. The idea behind is that not the weakest peer involved defines globally what information is transmitted with an filter. The consumer and the producer set some flags of the filter that describe the requirements of the consumer and the capabilities of the producer. There are two flags set by the producer:<ul>
<li>PropagateNoCase tells the consumer that the tag names used are case insensitive</li>
<li>PropagateNoAttr tells the consumer that producer does not know about attributes (only OpenTag,CloseTag,Value are used)</li>
</ul>
There is one flag set by the consumer:<ul>
<li>SerializeWithIndices tells the producer that the consumer has no structure description that helps to distinguish between an array with one element or a single element. Therefore the consumer has to produce a sequence that contains the information if an element belongs to an array. This is done by having one named tag for the array structure and one tag without name for every array element. Lets take an array with name "Colors" two atomic elements "Red" and "Blue" as example. Instead of producing a sequence like this, if SerializeWithIndices is not set <div class="fragment"><div class="line">OpenTag <span class="stringliteral">&quot;Colors&quot;</span>,Value <span class="stringliteral">&quot;Red&quot;</span>,CloseTag,OpenTag <span class="stringliteral">&quot;Colors&quot;</span>,Value <span class="stringliteral">&quot;Blue&quot;</span>,CloseTag</div>
</div><!-- fragment --> the following sequence has to be produced <div class="fragment"><div class="line">OpenTag <span class="stringliteral">&quot;Colors&quot;</span>,OpenTag,Value <span class="stringliteral">&quot;Red&quot;</span>,CloseTag,OpenTag,Value <span class="stringliteral">&quot;Blue&quot;</span>,CloseTag,CloseTag</div>
</div><!-- fragment --></li>
</ul>
Unfortunately we cannot define a format with array indices as unified format, because there are languages that do not have the capability to produce this information (like for example XML). So we take the weakest form as base and provide an upgrade if required and if the model behind allows it. The method <a class="el" href="class__Wolframe_1_1langbind_1_1FilterBase.html#a17c6bf4e3c7703145f6e6c21aad8d041" title="Set a flag (or a set of flags) ">_Wolframe::langbind::InputFilter::setFlags( Flags f)</a> can return false if it cannot provide the required information. See <a class="el" href="FilterModule.html">Filter module</a>. As a real example we suggest to have a look at src/modules/filter/cjson/.</li>
<li><b>Form</b> <b>Function:</b> Form functions (<a class="el" href="class__Wolframe_1_1langbind_1_1FormFunction.html" title="Form function interface. ">_Wolframe::langbind::FormFunction</a>) are functions with a structure as input and a structure as output. The input structure is represented by an iterator implementing the input filter interface (iterator on OpenTag,CloseTag,Attribute,Value elements) with typed values instead of strings (<a class="el" href="class__Wolframe_1_1langbind_1_1TypedInputFilter.html" title="Input filter with atomic values having a type. ">_Wolframe::langbind::TypedInputFilter</a>). In Wolframe any function in any language used for processing is implemented as form function. With this object type it is also possible to implement form functions in C++ (<a class="el" href="class__Wolframe_1_1serialize_1_1CppFormFunction.html" title="Function of language bindings implemented in C++ with a form as argument and as result. The forms are defined by a serialization description. ">_Wolframe::serialize::CppFormFunction</a>). See <a class="el" href="FormFunctionModule.html">C++ form function module</a>. As a real example we suggest to have a look at src/modules/function/graphix/.</li>
<li><b>Program</b> <b>type:</b> Program types define the loading of objects into the program library (<a class="el" href="class__Wolframe_1_1prgbind_1_1ProgramLibrary.html" title="Class representing the program library with all programs loaded. ">_Wolframe::prgbind::ProgramLibrary</a>). Each program type declares a file type to be of its own and loads every file of this type configured with 'program' in the 'Processor' section of the configuration. See <a class="el" href="ProgramTypeModule.html">Program type module</a>. As a real example we suggest to have a look at src/modules/cmdbind/aamap/.</li>
<li><b>DDL</b> <b>compiler:</b> DDL (data definition language) compilers are compilers for forms used to validate input and output. Currently only 'simpleform' is implemented. See <a class="el" href="DDLCompilerModule.html">Data definition language (DDL) compiler module</a>. As a real example we suggest to have a look at src/modules/ddlcompiler/simpleform/</li>
<li><b>Custom</b> <b>data</b> <b>type:</b> Custom data types (<a class="el" href="class__Wolframe_1_1types_1_1CustomDataType.html" title="Custom Data Type Definition. ">_Wolframe::types::CustomDataType</a>) define arithmetic types with some methods. The idea is to define arithmetic data types for things like date/time or currency only once and not for every language binding. Custom data types can be used in normalization programs and so in data forms to validate and normalize atomic elements. See <a class="el" href="CustomDataTypeModule.html">Custom data type module</a>. As a real example we suggest to have a look at src/modules/datatype/datetime/.</li>
<li><b>Normalization</b> <b>function:</b> Normalization functions (<a class="el" href="class__Wolframe_1_1types_1_1NormalizeFunction.html" title="Basic normalization function for atomic values (variant type) ">_Wolframe::types::NormalizeFunction</a>) are besides custom data types the basic bricks to define atomic data types in forms. This component type lets you define your own normalization functions. See <a class="el" href="NormalizerModule.html">Normalize function module</a>. As a real example, that is using resources, have a look at src/modules/normalize/string. For an example, that is not using resources have a look at src/modules/normalize/string/.</li>
<li><b>Runtime</b> <b>environment:</b> A runtime environment (<a class="el" href="class__Wolframe_1_1langbind_1_1RuntimeEnvironment.html" title="Runtime environment for functions that need it. (for example as structure hosting the CLR for ...">_Wolframe::langbind::RuntimeEnvironment</a>) is a configurable environment for functions that need a context for execution. The only case where a runtime environment is currently used in Wolframe is for .NET (Windows only). See <a class="el" href="RuntimeEnvironmentModule.html">Runtime environment host structure module</a>. The only real example we have is .NET at src/modules/cmdbind/dotnet/.</li>
<li><b>Authenticator</b> <b>unit:</b> An authenticator unit (_Wolframe::AAAA::AuthenticatorUnit) implements one or more authentication mechanisms. An authentication unit is chosen for authentication of the client if it is the first configured authentication unit in the configuration section AAAA that implements the mechanism chosen. The class processing the authentication is called authentication slice (<a class="el" href="class__Wolframe_1_1AAAA_1_1AuthenticatorSlice.html" title="This is the base class for authenticator slices implementations An authenticator has (usually) severa...">_Wolframe::AAAA::AuthenticatorSlice</a>). See <a class="el" href="AuthenticatorModule.html">Authenticator module</a>. As a real example we suggest to have a look at tests/modules/authentication/fakeauth/.</li>
<li><b>Database</b> <b>interface:</b> Wolframe has interfaces to execute queries on Sqlite3 and PostgreSQL databases. To define a new database interface, we have to implement the following interfaces:<ul>
<li>configuration (implements <a class="el" href="class__Wolframe_1_1config_1_1NamedConfiguration.html" title="A named configuration is a normal configuration that provides also an className function. ">_Wolframe::config::NamedConfiguration</a>)</li>
<li>database (implements <a class="el" href="class__Wolframe_1_1db_1_1Database.html" title="Base class for database interface. All databases should provide this interface. ">_Wolframe::db::Database</a>)</li>
<li>transaction execution statemachine (implements <a class="el" href="class__Wolframe_1_1db_1_1TransactionExecStatemachine.html" title="Interface to the database transaction execution statemechine. ">_Wolframe::db::TransactionExecStatemachine</a>)</li>
</ul>
The database and the configuration are the objects you have to declare when implementing a database module. See <a class="el" href="DatabaseModule.html">Database interface module</a>. As a real example have a look at src/modules/database/sqlite3/.</li>
</ul>
<h2><a class="anchor" id="ModuleConfiguration"></a>
Defining a module configuration</h2>
<p>For defining the configuration of a module we can either derive a class from <a class="el" href="class__Wolframe_1_1config_1_1NamedConfiguration.html" title="A named configuration is a normal configuration that provides also an className function. ">_Wolframe::config::NamedConfiguration</a> and implement the parsing by hand or we can derive from the class <a class="el" href="class__Wolframe_1_1serialize_1_1DescriptiveConfiguration.html">_Wolframe::serialize::DescriptiveConfiguration</a> and declare the configuration in a descriptive way. The first method is mainly used in the core for not getting into a dependency to the serialization library (libwolframe_serialize). In modules we suggest to use the declarative way of describing a configuration. The declarative way lets you describe the basic configuration structure as class with atomic types (integer types, std::string, float and bool) or subclasses or arrays (std::vector) of one of them. Additionaly you can overwrite some hooks to do additional checks or transformations. Each class that is part of a declarative configuration, either as main structure or as substructure needs to have a static method with the following signature as member: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="class__Wolframe_1_1serialize_1_1StructDescriptionBase.html">_Wolframe::serialize::StructDescriptionBase</a>* getStructDescription();</div>
</div><!-- fragment --><p> The method has to return a description of the structure for introspection because nativ C++ does not provide introspection on its own. The template class <a class="el" href="struct__Wolframe_1_1serialize_1_1StructDescription.html" title="Intrusive description of a filter/form map. ">_Wolframe::serialize::StructDescription</a> offers some methods to assign names to data members and to tag them with properties (like the property optional). The example in <a class="el" href="ConfigDescription.html">Descriptive configuration declaration example</a> describes a structure with a vector of substructures and some atomic elements. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 29 2014 16:26:43 for Wolframe by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</div>
</div>
<!-- /content -->
<!-- Footer -->
<div class="wrapper row2">
	<div id="footer" class="clear">
		<div class="one_third first">
			<h2 class="footer_title">Documentation</h2>
			<nav class="footer_nav">
				<ul class="nospace">
					<li><a href="/documentation.html">User documentation</a></li>
					<li><a href="/documentation.html">Developer documentation</a></li>
				</ul>
			</nav>
		</div>
		<div class="one_third">
			<h2 class="footer_title">Downloads</h2>
			<nav class="footer_nav">
				<ul class="nospace">
					<li><a href="/downloads.html">Hosted on Github</a></li>
					<li><a href="/downloads.html">Packages on Sourceforge</a></li>
				</ul>
			</nav>
		</div>
		<div class="one_third">
			<h2 class="footer_title">Contact Us</h2>
			<nav class="footer_nav">
				<ul class="nospace">
					<li><strong>Email:</strong> <a href="/mailto:contact@wolframe.net">contact@wolframe.net</a></li>
					<li>
						<a id="googleplus-bttn" href="http://plus.google.com/116915890857205562872?prsrc=3" rel="publisher" target="_top" style="text-decoration:none;">
							<span>Google+</span></a>
						<a  id="linkedin-bttn" href="#" target="_top" style="text-decoration:none;">
							<span>LinkedIn</span></a>
						<a id="twitter-bttn" href="http://twitter.com/ProjectWolframe" target="_top" style="text-decoration:none;">
							<span>twitter</span></a>
						<a id="rss-bttn" href="#" target="_top" style="text-decoration:none;">
							<span>rss</span></a>
					</li>
					<li>
						<a href="https://twitter.com/ProjectWolframe" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false">Follow @ProjectWolframe</a>
						<div class="google-follow-button"><div class="g-follow" data-annotation="none" data-height="20" data-href="http://plus.google.com/116915890857205562872" data-rel="publisher"></div></div>
						<div class="google-plusone-button"><div class="g-plusone" data-href="http://www.wolframe.net" data-size="medium"></div></div>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<div class="wrapper row4">
	<div id="copyright" class="clear">
		<p class="fl_left">Copyright &copy; 2014 - <a href="#">Project Wolframe</a> - All Rights Reserved</p>
		<p class="fl_right"><a href="/copyright.html">Copyrights and credits</a></p>
	</div>
</div>
<!-- Scripts -->
<script src="http://code.jquery.com/jquery-latest.min.js"></script>
<script src="http://code.jquery.com/ui/1.10.1/jquery-ui.min.js"></script>
<script>window.jQuery || document.write('\x3Cscript src="/layout/scripts/jquery-latest.min.js">\x3C\/script>\
\x3Cscript src="/layout/scripts/jquery-ui.min.js">\x3C\/script>')</script>
<script>jQuery(document).ready(function($){ $('img').removeAttr('width height'); });</script>
<script src="/layout/scripts/jquery-mobilemenu.min.js"></script>
<script src="/layout/scripts/custom.js"></script>
<!-- Google analytics tracking -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-46433226-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- Tweeter follow script -->
<script>
	!function( d, s, id )	{
		var js, fjs = d.getElementsByTagName(s)[0], p = /^http:/.test(d.location)?'http':'https';
		if( !d.getElementById( id ))	{
			js = d.createElement( s );
			js.id = id;
			js.src = p + '://platform.twitter.com/widgets.js';
			fjs.parentNode.insertBefore( js,fjs );
		}
	} ( document, 'script', 'twitter-wjs' );
</script>
<!-- Google +1, follow -->
<script type="text/javascript">
	window.___gcfg = {
		lang: 'en-US',
		parsetags: 'onload'
	};
	( function()	{
		var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		po.src = 'https://apis.google.com/js/plusone.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	}) ();
</script>
</body>
</html>
