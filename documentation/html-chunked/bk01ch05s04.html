<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5.4. Functions</title><link rel="stylesheet" type="text/css" href="/layout/styles/main.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="Wolframe documentation" /><link rel="up" href="bk01ch05.html" title="Chapter 5. Data processing" /><link rel="prev" href="bk01ch05s03.html" title="5.3. Command handler" /><link rel="next" href="bk01ch05s05.html" title="5.5. Forms" />
	<title xmlns="">Project Wolframe</title>
	<meta xmlns="" charset="utf-8" />
	<meta xmlns="" name="viewport" content="width=device-width, initial-scale=1.0" />

	<link xmlns="" rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />

	<link xmlns="" href="/layout/styles/main.css" rel="stylesheet" type="text/css" media="all" />
	<link xmlns="" href="/layout/styles/mediaqueries.css" rel="stylesheet" type="text/css" media="all" />

	<!--[if lt IE 9]>
		<link href="/layout/styles/ie/ie8.css" rel="stylesheet" type="text/css" media="all" />
		<script src="/layout/scripts/ie/css3-mediaqueries.min.js"></script>
		<script src="/layout/scripts/ie/html5shiv.min.js"></script>
	<![endif]-->


</head><body>


<div xmlns="" class="wrapper row1">
	<header id="header" class="full_width clear">
		<div id="header-logo">
			<h1><a href="/index.html">Project Wolframe</a></h1>
			<h2>The Straight Path to Successful Projects</h2>
		</div>
		<div id="header-search">
			<form id="cse-search-box" action="http://www.wolframe.net/gsearch.html">
				<input type="hidden" name="cx" value="007231504736047898702:wrnjvfljzvu" />
				<input type="hidden" name="ie" value="UTF-8" />
				<input type="text" name="q" size="31" />
<!--				<input type="submit" name="sa" value="&#xf002;" /> -->
				<input type="submit" name="sa" class="search-bttn" value="" />
			</form>
		</div>
	</header>
</div>

<!-- ################################################################################################ -->
<div xmlns="" class="wrapper row2">
	<nav id="topnav">
		<ul class="clear">
<!-- BEGIN MENU -->
			<li><a href="/index.html" title="Home">Home</a></li>
			<li><a href="/downloads.html" title="Downloads">Downloads</a></li>
			<li class="active"><a href="/documentation.html" title="Documentation">Documentation</a></li>
			<li><a class="drop" href="/support.html" title="Support">Support</a>
				<ul>
					<li><a href="/faqs.html" title="FAQ">FAQ</a></li>
					<li><a href="http://sourceforge.net/p/wolframe/mailman/" title="Mailing lists">Mailing lists</a></li>
				</ul>
			</li>
			<li class="last-child"><a href="/contact.html" title="Contact Us">Contact Us</a></li>
<!-- END MENU -->
		</ul>
	</nav>
</div>

<!-- ################################################################################################ -->
<div class="wrapper row3"><div id="container"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.4. Functions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="bk01ch05s03.html">Prev</a> </td><th width="60%" align="center">Chapter 5. Data processing</th><td width="20%" align="right"> <a accesskey="n" href="bk01ch05s05.html">Next</a></td></tr></table><hr /></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idp1389990084"></a>5.4. Functions</h2></div></div></div><p>This chapter describes how functions are linked to the logic tier. 
It gives an overview on the language bindings available for Wolframe.
</p><p>
For defining database transactions Wolframe introduces a language called TDL (Transaction Definition Language).
TDL embeddes the language of the underlaying database (SQL) in a language that defines how
sets of elements of input and output are addressed.
</p><p>
This chapter also describes how data types are defined that can be used in data definion languages
(DDL) for form desciptions. Forms and their definition will be introduced in a different chapter.
</p><p>
After reading this chapter you should be able to write functions of the <span class="application">Wolframe</span> logic tier on your own.
</p><p>
Be aware that you have to configure a programming language of the logic tier in <span class="application">Wolframe</span>
before using it. Each chapter introducing a programming language will have a section that describes how the server
configuration of <span class="application">Wolframe</span> has to be extended for its availability.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idp1390035164"></a>5.4.1. Transactions in TDL</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390035508"></a>Introduction</h4></div></div></div><p>
			For the description of transactions <span class="application">Wolframe</span>
			provides the transaction definition language (<acronym class="acronym">TDL</acronym>)
			introduced here. <span class="application">Wolframe</span> transactions 
			in <acronym class="acronym">TDL</acronym> are defined as functions in a transactional 
			context. This means that whatever is executed in a transaction 
			function belongs to a database transaction. The transaction
			commit is executed implicitely on function completion. Errors or 
			a denied authorization or a failing audit operation lead to an 
			abort of the database transaction.
		</p><p>
			A <acronym class="acronym">TDL</acronym> transaction function takes a structure 
			as input and returns a structure as output.
			The <span class="application">Wolframe</span> database interface defines 
			a transaction as object where the input is passed to as a structure 
			and the output is fetched from it as a structure.
		</p><p>
			TDL is a language to describe the building of transaction 
			input and the building of the result structure from the database output.
			It defines a transaction as a sequence of instructions on multiple data.
			An instruction is either described as a single embedded database command
			in the language of the underlying database or a TDL subroutine call
			working on multiple data.
		</p><p>
			Working on multiple data means that the instruction is executed
			for every item of its input set. This set can consist of the set of
			results of a previous instruction or a selection of the
			input of the transaction function. A "for each" selector
			defines the input set as part of the command.
		</p><p>
			Each instruction result can be declared as being part of the 
			transaction result structure. The language has no flow control 
			based on state variables other than input and results of 
			previous commands and is therefore not a general purpose programming 
			language. But because of this, the processing and termination of the 
			program is absolutely predictable.
		</p><p>
			As possibility to convert the input data before passing it to
			the database, the transaction definition language defines a 
			preprocessing section where globally defined Wolframe
			functions can be called for the selected input. To build an output 
			structure that cannot be modeled with a language without control
			structures and recursion, TDL provides the possibility to define a
			function as filter for postprocessing of the result of the 
			transaction function. This way it is for example possible to
			return a tree structure as TDL function result.
		</p><p>
			The TDL is - as most SQL databases - case insensitive. 
			For clearness and better readability TDL keywords are written in 
			uppercase here. We recommend in general to use uppercase letters 
			for TDL keywords. It makes the source more readable.
		</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390071236"></a>Configuration</h4></div></div></div><p>
		Each TDL program source referenced has to be declared in the 
		<code class="code">Processor</code> section of the configuration with 
		<code class="code">program &lt;sourcefile&gt;</code>.
		</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390072364"></a>Language description</h4></div></div></div><p>
		A TDL program consists of subroutine declarations and exported
		transaction function declarations. Subroutines have the same
		structure as transaction function blocks but without pre- and postprocessing
		and authorization method declarations.
		</p><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390073132"></a>Subroutines</h5></div></div></div><p>A subroutine declaration starts with the Keyword <code class="code">SUBROUTINE</code>
			followed by the subroutine name and optionally some parameter names
			in brackets ('(' ')') separated by comma.
			The declared subroutine name identifies the function in the scope 
			of this sourcefile after this subroutine declaration.
			The name is not exported and the subroutine not available for other TDL
			modules. With includes described later we can reuse code.
			The body of the function contains the following parts:
			</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><pre class="programlisting">DATABASE &lt;database name list&gt;</pre><p>
						This optional definition is restriction the 
						definition and availability of the function 
						to a set of databases. The databases are 
						listed by name separated by comma (','). 
						The names are the database id's defined in 
						your server configuration or database names
						as specified in the module.
						If the database declaration is omitted then the 
						transaction function is avaiable for any 
						database. This declaration allows you to
						run your application with configurations
						using different databases but sharing a common
						code base.
					</p></li><li class="listitem"><pre class="programlisting">BEGIN &lt;...instructions...&gt; END</pre><p>
					The main processing block starts with <code class="code">BEGIN</code>
					and ends with <code class="code">END</code>. It contains all the 
					commands executed when calling this subroutine from 
					another subroutine or a transaction function.
					</p></li></ul></div><p>
			The following pseudocode example shows the parts of a subroutine declaration:
			</p><pre class="programlisting">
			SUBROUTINE &lt;name&gt; ( &lt;parameter name list&gt; )
			DATABASE &lt;list of database names&gt;
			BEGIN
				...&lt;instructions&gt;...
			END
			</pre><p>
			The DATABASE declaration is optional.
			</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390078484"></a>Transaction function declarations</h5></div></div></div><p>A transaction function declaration starts with the Keyword <code class="code">TRANSACTION</code>
			followed by the name of the transaction function. This name identifies the
			function globally. The body of the function contains the following parts:
			</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><pre class="programlisting">AUTHORIZE ( &lt;auth-function&gt;, &lt;auth-resource&gt; )</pre><p>
						This optional definition is dealing with 
						authorization and access rights. If the
						authorization function fails, the transaction
						function is not executed and returns with error.
						The &lt;auth-function&gt; references a form
						function implementing the authorization check.
						The &lt;auth-resource&gt; is passed as parameter
						with name 'resource' to the function.
					</p></li><li class="listitem"><pre class="programlisting">DATABASE &lt;database name list&gt;</pre><p>
						This optional definition is restriction the
						definition and availability of the function 
						to a set of databases. The databases are listed 
						by name separated by comma (','). The names 
						are the database id's defined in your server 
						configuration. If the database declaration is 
						omitted then the transaction function is 
						avaiable for any database. This declaration
						allows you to run your application with 
						configurations using different databases but 
						sharing a common code base.
					</p></li><li class="listitem"><pre class="programlisting">RESULT FILTER &lt;post-filter-name&gt;</pre><p>
						This optional declaration defines a function
						applied as post filter to the transaction function.
						The idea is that you might want to return a structure
						as result that cannot be built by TDL. For example a
						recursive structure like a tree.
						The result filter function is called with the structure
						printed by the main processing block (BEGIN .. END)
						and the result of the filter function is returned to the
						caller instead.
					</p></li><li class="listitem"><pre class="programlisting">PREPROC &lt;...instructions...&gt; ENDPROC</pre><p>
						This optional block contains instructions on the transaction
						function input. The result of these preprocessing instructions are
						put into the input structure, so that they can be referenced in the main
						code definition block of the transaction.
						We can call any global normalization or form function in the 
						preprocessing block to enrich or transform the input to process.
					</p></li><li class="listitem"><pre class="programlisting">BEGIN &lt;...instructions...&gt; END</pre><p>
					The main processing block starts with <code class="code">BEGIN</code> and
					ends with <code class="code">END</code>. It contains all the database instructions
					needed for completing this transaction.
					</p></li><li class="listitem"><pre class="programlisting">AUDIT [CRITICAL] &lt;funcname...&gt; WITH BEGIN &lt;...instructions...&gt; END</pre><p>
						This optional block specifies a function
						that is executed at the end of a transaction.
						The input of the function is the structure built 
						from the output of the instructions block.
						If CRITICAL is specified then the transaction 
						fails (rollback) if the audit function fails.
						Otherwise there is just the error of
						the audit function logged, but the transaction 
						is completed (commit).
						You can specify several audit functions. 
						The variables in the instructions block refer 
						to the scope of the main processing
						block. So you can reference everything that is referencable
						after the last instruction of the main processing block.
					</p></li><li class="listitem"><pre class="programlisting">AUDIT [CRITICAL] &lt;funcname...&gt; ( &lt;...parameter...&gt; )</pre><p>
					If the input structure of the audit function is just one
					parameter list this alternative syntax for an audit function declaration
					can be used. You simply specify the audit function call after the
					AUDIT or optionally after the CRITICAL keyword.
					</p></li></ul></div><p>
			The following pseudo code snippet shows the explained building
			blocks in transaction functions together:
			</p><pre class="programlisting">
	
			TRANSACTION &lt;name&gt;
			AUTHORIZE ( &lt;auth-function&gt;, &lt;auth-resource&gt; )
			DATABASE &lt;list of database names&gt;
			RESULT FILTER &lt;post-filter-name&gt;
			PREPROC
				...&lt;preprocessing instructions&gt;...
			ENDPROC
			BEGIN
				...&lt;instructions&gt;...
			END
			AUDIT CRITICAL &lt;funcname&gt; ( ...&lt;parameter&gt;... )

			</pre><p>
			The lines with AUTHORIZE,DATABASE and RESULT FILTER are optional.
			So is the preprocessing block PREPROC..ENDPROC. A simpler
			transaction function looks like the following:
			</p><pre class="programlisting">
	
			TRANSACTION &lt;name&gt;
			BEGIN
				...&lt;instructions&gt;...
			END
			</pre><p>
			</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390090020"></a>Main processing instructions</h5></div></div></div><p>Main processing instructions defined in the main execution block 
			of a subroutine or transaction function consist of three parts in the
			following order terminated by a semicolon ';' (the order of the 
			INTO and FOREACH expression can be switched):
			</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><pre class="programlisting">INTO &lt;result substructure name&gt;</pre><p>
						This optional directive specifies if and where the results
						of the database commands should be put into as part of the
						function output. In subroutines this substructure is
						relative to the current substructure addressed in the
						callers context.
						For example a subroutine with an "INTO myres"
						directive in a block of an "INTO output"
						directive will write its result into a 
						substructure with path "output/myres".
					</p></li><li class="listitem"><pre class="programlisting">FOREACH &lt;selector&gt;</pre><p>
						This optional directive defines the set of 
						elements on which the instruction is executed one by one.
						Specifying a set of two elements will cause the function to
						be called twice. An empty set as selection will
						cause the instruction to be ignored. Without
						quantifier the database command or subroutine call
						of the instruction will be always be executed once.
					</p><p>
						The argument of the FOREACH expression is either
						a reference to the result of a previous 
						instruction or a path selecting a set of input
						elements.
					</p><p>
						Results of previous instructions are referenced either with
						the keyword RESULT referring to the result set
						of the previous command or with a variable
						naming a result set declared with this name before.
						
					</p><p>
						Input elements are selected by path relative
						to the path currently selected, starting from
						the input root element when entering a transaction
						function. The current path selected and the base
						element of any relative path calculated in this scope
						changes when a subroutine is called in a FOREACH selection
						context. For example calling a subroutine in a
						'FOREACH person' context will cause
						relative paths in this subroutine to be sub elements
						of 'person'.
					</p></li><li class="listitem"><pre class="programlisting">DO &lt;command&gt;</pre><p>
						Commands in an instruction are either embedded
						database commands or subroutine calls. 
						Command arguments are either constants or relative paths 
						from the selector path in the FOREACH selection
						or referring to elements in the result of 
						a previous command.
						If an argument is a relative path from the 
						selector context, its reference
						has to be unique in the context of the 
						element selected by the selector.
						If an argument references a previous command
						result it must either be unique or dependent
						an the FOREACH argument. 
						Results that are sets with more than one element
						can only be referenced if they are bound to 
						the FOREACH quantifier.
					</p></li></ul></div><p>
			</p><div class="sect5"><div class="titlepage"><div><div><h6 class="title"><a id="idp1390096148"></a>Main processing example</h6></div></div></div><p>The following example illustrate how the FOREACH,INTO,DO
				expressions in the main processing block work together:
				</p><pre class="programlisting">
				
TRANSACTION insertCustomerAddresses
BEGIN
    DO SELECT id FROM Customer
        WHERE name = $(customer/name);
    FOREACH /customer/address
        DO INSERT INTO Address (id,address)
        VALUES ($RESULT.id, $(address));
END

				</pre><p>
				</p></div></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390097860"></a>Preprocessing instructions</h5></div></div></div><p>Preprocessing instructions defined in the PREPROC execution block 
			of a transaction function consist similar to the instructions
			in the main execution block of three parts in the
			following order terminated by a semicolon ';' (the order of the INTO and FOREACH expression can be
			switched and has no meaning, e.g. FOREACH..INTO == INTO..FOREACH):
		</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><pre class="programlisting">INTO &lt;result substructure name&gt;</pre><p>
					This optional directive specifies if and where the results
					of the preprocessing commands should be put into as part
					of the input to be processed by the main processing
					instructions. The relative paths of the destination structure
					are calculated relative to a FOREACH selection element.
				</p></li><li class="listitem"><pre class="programlisting">FOREACH &lt;selector&gt;</pre><p>
					This optional directive defines the set of 
					elements on which the instruction is executed one by one.
					The preprocessing command is executed once for each 
					element in the selected set and it will not be executed 
					at all if the selected set is empty.
				</p></li><li class="listitem"><pre class="programlisting">DO &lt;command&gt;</pre><p>
					Commands in an instruction are function calls to
					globally defined form functions or normalization
					functions. Command arguments
					are constants or relative paths from the selector
					path in the FOREACH selection. They are uniquely
					referencing elements in the context of a selected element.
				</p></li></ul></div><p>
		</p><div class="sect5"><div class="titlepage"><div><div><h6 class="title"><a id="idp1390101892"></a>Preprocessing example</h6></div></div></div><p>The following example illustrate how the "FOREACH, INTO, DO"
				expressions in the main processing block work together:
				</p><pre class="programlisting">
				
TRANSACTION insertPersonTerms
PREPROC
    FOREACH //address/* INTO normalized
        DO normalizeStructureElements(.);
    FOREACH //id INTO normalized
        DO normalizeNumber(.);
ENDPROC
BEGIN
    DO UNIQUE SELECT id FROM Person
        WHERE name = $(person/name);
    FOREACH //normalized DO
        INSERT INTO SearchTerm (id, value)
        VALUES ($RESULT.id, $(.));
END

				</pre><p>
				</p></div></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390103612"></a>Selector path</h5></div></div></div><p>An element of the input or a set of input elements can be selected by a path.
			A path is a sequence of one of the following elements separated by slashes:
			</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><pre class="programlisting">Identifier</pre><p>
				An identifier uniquely selects a sub element of the current position in the tree.
				</p></li><li class="listitem"><pre class="programlisting">*</pre><p>
				Anp asterisk selects any sub element of the current position in the tree.
				</p></li><li class="listitem"><pre class="programlisting">..</pre><p>
				Two dots in a row select the parent element of the current position in the tree.
				</p></li><li class="listitem"><pre class="programlisting">.</pre><p>
				One dots selects the current element in the tree.
				This operator can also be useful as part of a path
				to force the expression to be interpreted
				as path if it could also be interpreted as a keyword of the 
				TDL language (for example <code class="code">./RESULT</code>).
				</p></li></ul></div><p>
			A slash at the beginning of a path selects the root element of the transaction function input tree.
			Two subsequent slashes express that the following node is (transitively) any descendant of the
			current node in the tree.
		</p><p>
			Paths can appear as argument of a FOREACH selector where they specify
			the set of elements on which the attached command is executed on.
			Or they can appear as reference to an argument in a command expression
			where they specify uniquely one element that is passed as argument 
			to the command when it is executed.
		</p><p>
			When used in embedded database statements, selector paths are referenced
			with <code class="code">$(&lt;path expression&gt;)</code>. When used as database
			function or subroutine call arguments path expressions can be used in
			plain without '$' and '(' ')' markers. These markers are just used to 
			identify substitution entities.
		</p><div class="sect5"><div class="titlepage"><div><div><h6 class="title"><a id="idp1390109260"></a>Path expression examples</h6></div></div></div><p>The following list shows different ways of addressing an element by path:
				</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><pre class="programlisting">/</pre><p>Root element</p></li><li class="listitem"><pre class="programlisting">/organization</pre><p>Root element with name "organization"</p></li><li class="listitem"><pre class="programlisting">/organization/address/city</pre><p>Element "city" of root "organization" descendant "address"</p></li><li class="listitem"><pre class="programlisting">.//id</pre><p>Any descendant element with name "id" of the current element</p></li><li class="listitem"><pre class="programlisting">//person/id</pre><p>Child with name "id" of any descendant "person" of the root element</p></li><li class="listitem"><pre class="programlisting">//id</pre><p>Any descendant element with name "id" of the root element</p></li><li class="listitem"><pre class="programlisting">/address/*</pre><p>Any direct descendant of the root element "address"</p></li><li class="listitem"><pre class="programlisting">.</pre><p>Currently selected element</p></li></ul></div><p>
				</p></div><div class="sect5"><div class="titlepage"><div><div><h6 class="title"><a id="idp1390115500"></a>Path usage example</h6></div></div></div><p>This example shows the usage of path expression in the
			preprocessing and the main processing part of a transaction function:
			</p><pre class="programlisting">
			
TRANSACTION selectPerson
PREPROC
    FOREACH /person/name
        INTO normalized DO normalizeName( . );
    FOREACH /person
        INTO citycode DO getCityCode( city );
ENDPROC
BEGIN
    FOREACH person
        DO INSERT INTO Person (Name,NormalizedName,CityCode)
            VALUES ($(name),$(name/normalized),$(citycode));
END


			</pre><p>
			</p></div></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390117164"></a>Referencing Database Results</h5></div></div></div><p>Database results of the previous instruction are referenced 
			with a '$RESULT.' followed by the column identifier or column number.
			Column numbers start always from 1, independent from the database!
			So be aware that even if the database counts column from 0 you have
			to use 1 for the first column. 
			</p><p>
			As already explained before, database result sets of cardinality 
			bigger than one cannot be addressed if not bound to a FOREACH
			selection. In statements potentially addressing more than one 
			result element you have to add a <code class="code">FOREACH RESULT</code> quantifier.
			</p><p>
			For addressing results of instructions preceding the previous instruction,
			you have to name them (see next section). The name of the result can then
			be used as FOREACH argument to select the elements of a set to be
			used as base for the command arguments of the instruction. Without
			binding instruction commands with a FOREACH quantifier the named 
			results of an instruction can be referenced as
			<code class="code">$&lt;name&gt;.&lt;columnref&gt;</code>,
			for example as <code class="code">$person.id</code> for the column with name 'id' of the
			result named as 'person'.
			</p><p>
			The 'RESULT.' prefix in references to the previous instruction result
			is a default and can be omitted in instructions that are not 
			explicitly bound to any other result than the last one. So the following
			two instructions are equivalent:
			</p><pre class="programlisting">
			DO SELECT name FROM Company
			    WHERE id = $RESULT.id
			DO SELECT name FROM Company
			    WHERE id = $id
			</pre><p>
			and so are the following two instructions:
			</p><pre class="programlisting">
			FOREACH RESULT
			    DO SELECT name FROM Company
			        WHERE id = $RESULT.id
			FOREACH RESULT
			    DO SELECT name FROM Company
			        WHERE id = $id
			</pre><p>
			</p><p>
			The result name prefix of any named result can also be omitted if the
			instruction is bound to a FOREACH selector naming the result. So the 
			following two statements in the context of an existing database
			result named "ATTRIBUTES" are equivalent:
			</p><pre class="programlisting">
			FOREACH ATTRIBUTES
			    DO SELECT name FROM Company
			        WHERE id = $ATTRIBUTES.id
			FOREACH ATTRIBUTES
			    DO SELECT name FROM Company
			        WHERE id = $id
			</pre><p>
			</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390122580"></a>Naming database results</h5></div></div></div><p>Database results can be hold and made referenceable by name
				with the declaration <code class="code">KEEP AS &lt;resultname&gt;</code>
				following immediately the instruction with the result to be referenced.
				The identifier &lt;resultname&gt; references the
				result in a variable reference or a FOREACH selector expression.
				</p><div class="sect5"><div class="titlepage"><div><div><h6 class="title"><a id="idp1390124004"></a>Named Result Example</h6></div></div></div><p>This example illustrates how a result is declared by name and referenced:
				</p><pre class="programlisting">
TRANSACTION selectDevices
BEGIN
    DO SELECT id FROM DevIdMap
        WHERE name = $(device/name);
    KEEP AS dev;
    FOREACH dev
        DO SELECT key,name,registration
            FROM Devices WHERE sid=$id;
END


				</pre><p>
				</p></div></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390125556"></a>Referencing Subroutine Parameters</h5></div></div></div><p>
				Subroutine Parameters are addressed like results but with
				the prefix <code class="code">PARAM.</code> instead of <code class="code">RESULT.</code>
				or a named result prefix. "PARAM." is reserved for parameters.
				The first instruction without FOREACH quantifier can reference
				the parameters without prefix by name.
				</p><pre class="programlisting">SUBROUTINE selectDevice( id)
BEGIN
    INTO device
        DO SELECT name FROM DevIdMap
            WHERE id = $PARAM.id;
END

TRANSACTION selectDevices
BEGIN
    DO selectDevice( id );
END

				</pre><p>
				</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390127716"></a>Constraints on database results</h5></div></div></div><p>Database commands returning results can have constraints to catch
			certain errors that would not be recognized at all or too late otherwise.
			For example a transaction having a result of a previous command as argument
			would not be executed if the result of the previous command is empty.
			Nevertheless the overall transaction would succeed because no database
			error occurring during execution of the commands defined for the 
			transaction.
			</p><p>
			Constraints on database results are expressed as keywords following
			the DO keyword of an instruction in the main processing section.
			If a constraint on database results is violated the whole transaction
			fails and a rollback occurrs.
			</p><p>
			The following list explains the result constraints available:
			</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><pre class="programlisting">NONEMPTY</pre><p>Declares that the database result for each element of the input
					must not be empty.</p></li><li class="listitem"><pre class="programlisting">UNIQUE</pre><p>Declares that the database result for each element of the input 
					must be unique, if it exists.
					Result sets with more than one element are refused 
					but empty sets are accepted. If you
					want to declare each result to have to exist, 
					you have to put the double constraint
					"UNIQUE NONEMPTY" or "NONEMPTY UNIQUE".</p></li></ul></div><p>
			</p><div class="sect5"><div class="titlepage"><div><div><h6 class="title"><a id="idp1390131348"></a>Example with result constraints</h6></div></div></div><p>
				This example illustrates how to add result constraint for
				database commands returning results:
				</p><pre class="programlisting">
				
TRANSACTION selectCustomerAddress
BEGIN
    DO NONEMPTY UNIQUE SELECT id FROM Customer
        WHERE name = $(customer/name);
    INTO address
        DO NONEMPTY SELECT street,city,country
            FROM Address WHERE id = $id;
END


				</pre><p>
				</p></div></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390133044"></a>Rewriting error messages for the client</h5></div></div></div><p>Sometimes internal error messages are confusing and are not helpful
			to the user that does not have a deeper knowledge about the database
			internals. For a set of error types it is possible to add a message
			to be shown to the user if an error of a certain class happens.
			The instruction <code class="code">ON ERROR &lt;errorclass&gt; HINT &lt;message&gt;;</code>
			following a database instruction catches the errors of class &lt;errorclass&gt;
			and add the string &lt;message&gt; to the error message show to the user.
			</p><p>We can have many subsequent ON ERROR definitions in a row if the
			error classes to be caught are various.
			</p><div class="sect5"><div class="titlepage"><div><div><h6 class="title"><a id="idp1390134788"></a>Database error HINT example</h6></div></div></div><p>The following example shows the usage HINTs in error cases. It
			catches errors that are constraint violations (error class CONSTRAINT)
			and extends the error message with a hint that will be shown to the client as error message:
			</p><pre class="programlisting">
			
TRANSACTION insertCustomer
BEGIN
    DO INSERT INTO Customer (name) VALUES ($(name));
    ON ERROR CONSTRAINT
        HINT "Customers must have a unique name.";
END

			</pre><p>
			</p><p>
			On the client side the following message will be shown:
			</p><pre class="programlisting">
			unique constaint violation in transaction 'insertCustomer'
			-- Customers must have a unique name.
			</pre><p>
			</p></div></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390137372"></a>substructures in the result</h5></div></div></div><p>We already learned how to define substructures of the 
			transaction function result with the <code class="code">RESULT INTO</code>
			directive of a TRANSACTION. 
			But we can also define a scope in the result structure
			for sub blocks. A sub-block in the result is declared with 
			</p><pre class="programlisting">

				INTO &lt;resulttag&gt;
				BEGIN
					...&lt;instruction list&gt;...
				END
			</pre><p>
			All the results of the instruction list that get into the final result
			will be attached to the substructure with name &lt;resulttag&gt;.
			The nesting of result blocks can be arbitrary and the path of the 
			elements in the result follows the scope of the sub-blocks.
			</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390139732"></a>Explicit sefinition of elements in the result</h5></div></div></div><p>The result of a transaction consists normally of database command 
			results that are mapped into the result with the attached INTO directive.
			For printing variable values or constant values you can in certain
			SQL databases use a select constant statement without specifying a table.
			Unfortunately select of constants might not be supported in your 
			database of choice. Besides that explicit printing seems to be much
			more readable. The statement <code class="code">INTO &lt;resulttag&gt; PRINT &lt;value&gt;;</code>
			prints a value that can be a constant, variable or an input or result reference
			into the substructure named &lt;resulttag&gt;. The following artificial 
			example illustrates this.
			</p><pre class="programlisting">
			
TRANSACTION doPrintX
BEGIN
  INTO person
  BEGIN
    INTO name PRINT 'jussi';
    INTO id PRINT '1';
  END
END


			</pre><p>
			</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390142212"></a>Database specific code</h5></div></div></div><p>TDL allows the support of different transaction databases with one code base. 
			For example one for testing and demonstration and one for the productive system.
			We can tag transactions,subroutines or whole TDL sources as beeing valid for one or a list of databases
			with the command <code class="code">DATABASE</code> followed by a comma separated list of database names as declared in
			the configuration. The following example declares the transaction function 'getCustomer' to be valid only for
			the databases DB1 and DBtest.
			</p><pre class="programlisting">
			
TRANSACTION getCustomer
DATABASE DB1,DBtest
BEGIN
    INTO customer
        DO SELECT * FROM CustomerData
            WHERE ID=$(id);
END


			</pre><p>
			The following example does the same but declares the valid databases for the whole TDL file. In this case the database
			declaration has to appear as first declaration in the file.
			</p><pre class="programlisting">
			
DATABASE DB1,DBtest

TRANSACTION getCustomer
BEGIN
    INTO customer DO SELECT *
        FROM CustomerData WHERE ID=$(id);
END


			</pre><p>
			</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390145540"></a>Subroutine templates</h5></div></div></div><p>To reuse code with different context, for example for doing the same
			procedure on different tables, subroutine templates can be defined in TDL.
			Subroutine templates become useful when we want to make items instantiable
			that are not allowed to be dependent on variable arguments.
			Most SQL implementations for example forbid tables to be dependent on
			variable arguments. To reuse code on different tables you can 
			define subroutine templates with the involved table names as 
			template argument. The following example defines a transaction using 
			the template subroutine insertIntoTree on a table passed as template 
			argument. The subroutine template arguments are substituting the identifiers
			in embedded database statements by the passed identifier. Only whole identifiers
			and not substrings of identifiers and no string contents are substituted.
			</p><pre class="programlisting">
			
TEMPLATE &lt;TreeTable&gt;
SUBROUTINE insertIntoTree( parentID)
BEGIN
    DO NONEMPTY UNIQUE SELECT rgt FROM TreeTable
        WHERE ID = $PARAM.parentID;
    DO UPDATE TreeTable
        SET rgt = rgt + 2 WHERE rgt &gt;= $1;
    DO UPDATE TreeTable
        SET lft = lft + 2 WHERE lft &gt; $1;
    DO INSERT INTO TreeTable (parentID, lft, rgt)
        VALUES ( $PARAM.parentID, $1, $1+1);
    DO NONEMPTY UNIQUE SELECT ID AS "ID" from TreeTable
        WHERE lft = $1;
END

TRANSACTION addTag
BEGIN
    DO insertIntoTree&lt;TagTable&gt;( $(parentID) )
    DO UPDATE TagTable
        SET name=$(name),description=$(description)
            WHERE ID=$RESULT.id;
END


			</pre><p>
			</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390147900"></a>Includes</h5></div></div></div><p>TDL has the possibility to include files for reusing subroutines 
			or subroutine templates in different modules.
			The keyword INCLUDE followed by the name of the relative path of the TDL file without the extension .tdl includes the declarations of the included file.
			The declarations in the included file are treated as they would have been
			made in the including file instead.
			The following example swhows the use of include.
			We assume that the subroutine template <code class="code">insertIntoTree</code> 
			of the example before is defined in a separate include file
			<code class="code">treeOperations.tdl</code> located in the same folder as the 
			TDL program.
			</p><pre class="programlisting">
			
INCLUDE treeOperations

TRANSACTION addTag
BEGIN
    DO insertIntoTree&lt;TagTable&gt;( $(parentID) )
    DO UPDATE TagTable
        SET name=$(name),description=$(description)
            WHERE ID=$RESULT.id;
END



			</pre><p>
			</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390150812"></a>Auditing</h5></div></div></div><p>TDL defines hooks to add function calls for auditing transactions. An
			audit call is a form function call with a structure build from transaction input
			and some database results. An auditing function call can be marked as critical, so
			that the final commit is dependent not only on the transaction success but also on
			the success of the auditing function call. The following two examples show equivalent
			calls of audit. One with the function call syntax for calls with a flat structure
			(only atomic parameters) as parameter and one with the parameter build from a
			result structure of a BEGIN..END block executed. The later one can be used for
			audit function calls with a more complex parameter structure.
			</p><div class="sect5"><div class="titlepage"><div><div><h6 class="title"><a id="idp1390152060"></a>Audit example with function call syntax</h6></div></div></div><pre class="programlisting">
				
TRANSACTION doInsertUser
BEGIN
	DO INSERT INTO Users (name) values ($(name));
	DO SELECT id FROM Users WHERE name = $(name);
END
AUDIT CRITICAL auditUserInsert( $RESULT.id, $(name) )



				</pre></div><div class="sect5"><div class="titlepage"><div><div><h6 class="title"><a id="idp1390153380"></a>Audit example with parameter as structure</h6></div></div></div><pre class="programlisting">
				
TRANSACTION doInsertUser
BEGIN
	DO INSERT INTO Users (name) values ($(name));
	DO SELECT id FROM Users WHERE name = $(name);
END
AUDIT CRITICAL auditUserInsert WITH
BEGIN
	INTO id PRINT $RESULT.id;
	INTO name PRINT $(name);
END



				</pre></div></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idp1390215044"></a>5.4.2. Functions in .NET</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390215364"></a>Introduction</h4></div></div></div><p>You can write functions for the logic tier of <span class="application">Wolframe</span> in languages based
		on <span class="application">.NET</span> (<a class="ulink" href="http://www.microsoft.com/net" target="_top">http://www.microsoft.com/net</a>) like for example
		<span class="application">C#</span> and <span class="application">VB.NET</span>.  
		Because <span class="application">.NET</span> based libraries can only be called 
		by <span class="application">Wolframe</span> as a compiled and not as an 
		interpreted language, you have to build a <span class="application">.NET</span> assembly out of a group of 
		function implementations before using it. There are further restrictions 
		on a <span class="application">.NET</span> implementation.
		We will discuss all of them, so that you should be able
		to write and configure <span class="application">.NET</span> assemblies for using in 
		<span class="application">Wolframe</span> on your own after reading this chapter.
		</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390249724"></a>Configuration</h4></div></div></div><p>For enabling <span class="application">.NET</span> you have to declare the loading of the module 'mod_command_dotnet'
		in the main section of the server configuration file.
		</p><pre class="programlisting">
		
    module mod_command_dotnet

		</pre><p>
		For the configuration of the <span class="application">.NET</span> assemblies to be loaded, see section 'Configure .NET Modules'.
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390252108"></a>Function interface</h4></div></div></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390252428"></a>Function context</h5></div></div></div><p>In <span class="application">.NET</span> the building blocks for functions called by <span class="application">Wolframe</span>
		are classes and method calls. The way of defining callable items for 
		<span class="application">Wolframe</span> is restricted either due to the current 
		state of the <span class="application">Wolframe</span> COM/.NET interoperability
		implementation or due to general or version dependent restrictions of 
		<span class="application">.NET</span> objects exposed via COM/.NET interop.
		We list here the restrictions:
		</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The methods exported as functions for <span class="application">Wolframe</span>
			must not be defined in a nested class. They should be defined in a top level class 
			without namespace. This is a restriction imposed by the current development 
			state of Wolframe.</p></li><li class="listitem"><p>The class must be derived from an interface with all methods
			exported declared.</p></li><li class="listitem"><p>The methods must not be static because COM/.NET interop,
			as far as we know, cannot cope with static method calls. Even if the 
			methods nature is static, they have to be defined as ordinary method calls.</p></li></ul></div><p>
		</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390256972"></a>Function signature</h5></div></div></div><p>
		Functions callable from <span class="application">Wolframe</span> take an arbitrary 
		number of arguments as input and return a structure (<code class="code">struct</code>) as 
		output. The named input parameters referencing atomic elements or complex 
		structures are forming the input structure of the <span class="application">Wolframe</span> 
		function. A <span class="application">Wolframe</span> function called with a 
		structure containing the elements "A" and "B" is implemented in 
		<span class="application">.NET</span> as function taking two arguments
		with the name "A" and "B". Both "A" and "B" can represent either atomic elements 
		or arbitrary complex structures. <span class="application">.NET</span> functions
		that need to call global <span class="application">Wolframe</span> functions,
		for example to perform database transactions, need to declare 
		a <code class="code">ProcProvider</code> interface from <span class="application">Wolframe</span>
		namespace as additional parameter. We will describe the <code class="code">ProcProvider</code>
		interface in a separate section of this chapter.
		</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390261060"></a>Example</h5></div></div></div><p>The following simple example without provider context is declared 
		without marshalling and introspection tags. It can therefore not be called
		by <code class="code">Wolframe</code>. We explain later how to make it callable. 
		The example just illustrates the structure of the exported object with
		its interface (example <span class="application">C#</span>):
		</p><pre class="programlisting">
		
using System;
using System.Runtime.InteropServices;

public struct Address
{
    public string street;
    public string country;
};

public interface FunctionInterface
{
    Address GetAddress( string street, string country);
}

public class Functions : FunctionInterface
{
    public Address GetAddress( string street, string country)
    {
        Address rt = new Address();
        rt.street = street;
        rt.country = country;
        return rt;
    }
}


		</pre><p>
		</p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390263460"></a>Prepare .NET assemblies</h4></div></div></div><p>
	<span class="application">Wolframe</span> itself is not a <span class="application">.NET</span> application. Therefore it has to call
	<span class="application">.NET</span> functions via COM/.NET interop interface of a hosted CLR
	(Common Language Runtime).
	To make functions written in <span class="application">.NET</span> callable by <span class="application">Wolframe</span>, the following steps
	have to be performed:
	</p><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390265716"></a>Make assemblies COM visible</h5></div></div></div><p>
		First the asseblies with the functions exported to <span class="application">Wolframe</span> have to be build COM visible.
		To make the <span class="application">.NET</span> functions called from <span class="application">Wolframe</span> COM visible, you have to tick
		"Properties/Assembly Information" the switch "Make assembly COM visible". Furthermore
		every object and method that is part of the exported API (also objects used as parameters)
		has to be tagged in the source as COM visible with <code class="code">[ComVisible(true)]</code>.
		</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390267812"></a>Tag exported objects with a Guid</h5></div></div></div><p>Each object that is part of the exported API has to be tagged with a global unique
		identifier (Guid) in order to be adressable. Modules with <span class="application">.NET</span> functions will have to be globally
		registered and the objects need to be identified by the Guid because that's the only way
		to make the record info structure visible for <span class="application">Wolframe</span>. The record info structure is
		needed to serialize/deserialize <span class="application">.NET</span> objects from another interpreter context that
		is not registered for <span class="application">.NET</span>. There are many ways to create a Guid and
		tag an object like this: <code class="code">[Guid("390E047F-36FD-4F23-8CE8-3A4C24B33AD3")]</code>.
		</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390270492"></a>Add marshalling tags to values</h5></div></div></div><p>For marshalling function calls correctly, <span class="application">Wolframe</span> needs
		tags for every parameter and member of a sub structure of a parameter
		of methods exported as functions.
		The following table lists the supported types and their marshalling tags:
		</p><div class="table"><a id="idp1390271604"></a><p class="title"><strong>Table 5.2. Marshalling Tags</strong></p><div class="table-contents"><table summary="Marshalling Tags" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>.NET Type</th><th>Marshalling Tag</th></tr></thead><tbody><tr><td>I2</td><td><code class="code">[MarshalAs(UnmanagedType.I2)]</code></td></tr><tr><td>I4</td><td><code class="code">[MarshalAs(UnmanagedType.I4)]</code></td></tr><tr><td>I8</td><td><code class="code">[MarshalAs(UnmanagedType.I8)]</code></td></tr><tr><td>UI2</td><td><code class="code">[MarshalAs(UnmanagedType.UI2)]</code></td></tr><tr><td>UI4</td><td><code class="code">[MarshalAs(UnmanagedType.UI4)]</code></td></tr><tr><td>UI8</td><td><code class="code">[MarshalAs(UnmanagedType.UI8)]</code></td></tr><tr><td>R4</td><td><code class="code">[MarshalAs(UnmanagedType.R4)]</code></td></tr><tr><td>R8</td><td><code class="code">[MarshalAs(UnmanagedType.R8)]</code></td></tr><tr><td>BOOL</td><td><code class="code">[MarshalAs(UnmanagedType.BOOL)]</code></td></tr><tr><td>string</td><td><code class="code">[MarshalAs(UnmanagedType.BStr)]</code></td></tr><tr><td>RECORD</td><td><p>no tag needed</p></td></tr><tr><td>array of structures</td><td><code class="code">[MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_RECORD)]</code></td></tr><tr><td>array of strings</td><td><code class="code">[MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_BSTR)]</code></td></tr><tr><td>array of XX (XX=I2,I4,I8,..)</td><td><code class="code">[MarshalAs(UnmanagedType.SafeArray, SafeArraySubType = VarEnum.VT_XX)]</code></td></tr></tbody></table></div></div><br class="table-break" /><p>Decimal floating point and numeric types (DECIMAL) are not yet supported, but
		will soon be available.</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390284244"></a>Example with COM introspection tags</h5></div></div></div><p>The following C# module definition repeats the example introduced above with the
		correct tagging for COM visibility and introspection:
		</p><pre class="programlisting">
		
using System;
using System.Runtime.InteropServices;

[ComVisible(true)]
[Guid("390E047F-36FD-4F23-8CE8-3A4C24B33AD3")]
public struct Address
{
    [MarshalAs(UnmanagedType.BStr)] public string street;
    [MarshalAs(UnmanagedType.BStr)] public string country;
};

[ComVisible(true)]
public interface FunctionInterface
{
    [ComVisible(true)]  Address GetAddress( [MarshalAs(UnmanagedType.BStr)] string street, [MarshalAs(UnmanagedType.BStr)] string country);
}

[ComVisible(true)]
[ClassInterface(ClassInterfaceType.None)]
public class Functions : FunctionInterface
{
    public Address GetAddress([MarshalAs(UnmanagedType.BStr)] string street, [MarshalAs(UnmanagedType.BStr)] string country)
    {
        Address rt = new Address();
        rt.street = street;
        rt.country = country;
        return rt;
    }
}


		</pre><p>
		</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390285956"></a>Create a type library</h5></div></div></div><p>For making the API introspectable by <span class="application">Wolframe</span>, we have to create a TLB
		(Type Library) file from the assembly (DLL) after build. The type library has
		to be recreated every time the module interface (API) changes. The type library is
		created with the program <code class="code">tlbexp</code>. All created type library (.tlb) file
		that will be loaded with the same runtime environment have to be copied into
		the same directory. They will be referenced for introspection in the 
		configuration. The configuration of <span class="application">.NET</span> will be explained later.
		</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390287852"></a>Register the type library</h5></div></div></div><p>The type library created with <code class="code">tlbexp</code> has also to be registered.
		For this you call the program <code class="code">regtlibv12</code> with your type library file
		(.tlb file) as argument. The type libary fegistration has to be repeated when
		the the module interface (API) changes.
		</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390289084"></a>Register the assembly in the GAC</h5></div></div></div><p><span class="application">Wolframe</span> does not accept local assemblies. In order to be addressable over
		the type library interface assemblies need to be put into the global assembly cache (GAC).
		Unfortunately this has to be repeated every time the assembly binary changes.
		There is no way around. For the registration in the GAC we have to call the program
		<code class="code">gacutil /if &lt;assemblypath&gt;</code> with the assembly path &lt;assemblypath&gt;
		as argument. The command <code class="code">gacutil</code> has to be called from
		administrator command line. Before calling <code class="code">gacutil</code>, assemblies
		have to be strongly signed. We refer here to the MSDN documentation for how
		to sign an application.
		</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390291236"></a>Register the types in the assembly</h5></div></div></div><p>We have to register the types declared in the assembly
		to enable <span class="application">Wolframe</span> to create these types.
		An example could be a provider function returning a structure that is called
		from a <span class="application">Wolframe</span> .NET function. The structure
		returned here has to be build in an unmanaged context. In order to be valid
		in the managed context, the type has to be registered.
		For the registration of the types in an assembly we have to call the program
		<code class="code">regasm &lt;assemblypath&gt;</code> with the assembly path &lt;assemblypath&gt;
		as argument. The command <code class="code">regasm</code> has to be called from
		administrator command line.
		</p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390293668"></a>Calling Wolframe functions</h4></div></div></div><p>Wolframe functions in <span class="application">.NET</span> calling globally 
	defined <span class="application">Wolframe</span> 
	functions need to declare the processor provider interface as an additional parameter.
	The processor provider interface is defined as follows (example <span class="application">C#</span>):
	</p><pre class="programlisting">
	
namespace Wolframe
{
    public interface ProcProvider
    {
        object call(
        [In] string funcname,
        [In] object argument,
        [In] Guid resulttype);
    }
}

	</pre><p>
	To use it we have to include the reference to the assembly <code class="code">WolframeProcessorProvider.DLL</code>.
	</p><p>
	The interface defined there has a method <code class="code">call</code> taking 3 arguments: The name of the
	function to call, the object to pass as argument and the <code class="code">Guid</code> of the object type
	to return. The returned object will be created with help of the registered <code class="code">Guid</code>
	and can be casted to the type with this <code class="code">Guid</code>.
	</p><p>
	The following example shows the usage of a <code class="code">Wolframe.ProcProvider</code> call.
	The method <code class="code">GetUserObject</code> is declared as <span class="application">Wolframe</span> function requiring the processor
	provider context as additional argument and taking one object of type <code class="code">User</code> as
	argument named <code class="code">usr</code>.
	The example function implementation redirects the call to the global <span class="application">Wolframe</span> function
	named <code class="code">GetAddress</code> returning an object of type <code class="code">Address</code>
	(example <span class="application">C#</span>):
	</p><pre class="programlisting">
	
public Address GetUserAddress(
            Wolframe.ProcProvider provider,
            User usr
) {
    Address rt = (Address)provider.call(
                     "GetAddress", usr,
                     typeof(Address).GUID);
    return rt;
}

	</pre><p>
	The objects involved in this example need no more tagging because the provider context and also
	structures (<code class="code">struct</code>) need no additional mashalling tags.
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390301684"></a>Configure .NET assemblies</h4></div></div></div><p>
	<span class="application">.NET</span> modules are grouped together in a configuration block that specifies the configuration
	of the Microsoft Common Language Runtime (CLR) used for <span class="application">.NET</span> interop calls. The configuration
	block has the header <code class="code">runtimeEnv dotNET</code> and configures the version of the 
	runtime loaded (clrversion) and the path where the typelibraries (.tlb) files can be 
	found (typelibpath).
	</p><p>
	With the <code class="code">assembly</code> definitions you declare the registered assemblies to load.
	</p><pre class="programlisting">
	
RuntimeEnv dotNet
{
    clrversion   "v4.0.30319"
    typelibpath  programs/typelibrary
    assembly     "Functions, Version=1.0.0.30, Culture=neutral, PublicKeyToken=1c1d731dc6e1cbe1, processorArchitecture=MSIL"
    assembly     "Utilities, Version=1.0.0.27, Culture=neutral, PublicKeyToken=1c1f723cc51212ef, processorArchitecture=MSIL"
}

	</pre><p>
	</p><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390304724"></a>Assembly Declaration</h5></div></div></div><div class="table"><a id="idp1390305044"></a><p class="title"><strong>Table 5.3. Attributes of assembly declarations</strong></p><div class="table-contents"><table summary="Attributes of assembly declarations" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>&lt;no identifier&gt;</td><td>The first element of the assembly definition does not have an attribute identifier. 
					The value is the name of the assembly (and also of the type library)</td></tr><tr><td>Version</td><td>4 element (Major.Minor.Build.Revision) version number of the assembly.
					This value is defined in the assembly info file of the assembly project.</td></tr><tr><td>Culture</td><td>For <span class="application">Wolframe</span> applications until now always "neutral".
					Functionality is in Wolframe not yet culture dependent on the server side.</td></tr><tr><td>PublicKeyToken</td><td>Public key token values for signed assemblies. See next section how to set it.</td></tr><tr><td>processorArchitecture</td><td>Meaning not explained here. Has on ordinary Windows <span class="application">.NET</span>
					plattforms usually the value "MSIL". Read the MSDN 
					documentation to dig deeper.</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390311292"></a>Get the PublicKeyToken</h5></div></div></div><p>
		We already found out that <span class="application">Wolframe</span> <span class="application">.NET</span> modules 
		have to be strongly signed. 
		Each strongly signed assembly has such a public key token
		that has to be used as attribute when referencing the assembly.
		</p><p>
		We can get the <code class="code">PublicKeyToken</code> of the assembly 
		by calling <code class="code">sn -T &lt;assemblypath&gt;</code> from the command line (cmd)
		with &lt;assemblypath&gt; as the path of the assembly. The printed value is the
		public key to insert as attribute value of <code class="code">PublicKeyToken</code> in the
		<span class="application">Wolframe</span> configuration for each <span class="application">.NET</span> assembly.
		</p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390314628"></a>Validation issues</h4></div></div></div><p>
	Languages of <span class="application">.NET</span> called via the CLR are strongly typed languages. This means that
	the input of a function and the output is already validated to be of a strictly
	defined structure. So a validation by passing the input through a form
	might not be needed anymore. Validation with <span class="application">.NET</span> 
	data structures is weaker than for example XML validation with forms defined in
	a schema language. But only if distinguishing XML attributes from content elements
	is an issue. 
	See in the documentation of the standard command handler how validation can be
	skipped with the attribute <code class="code">SKIP</code>.
	</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idp1390362508"></a>5.4.3. Functions in python</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390362828"></a>Current development status</h4></div></div></div><p>You can write functions for the logic tier of <span class="application">Wolframe</span> in the 
		<span class="application">Python</span> programming language (<a class="ulink" href="http://www.python.org" target="_top">http://www.python.org</a>).
		</p><p>
		The implementation of <span class="application">Python</span> calls is not yet available. 
		But <span class="application">Wolframe</span> will provide <span class="application">Python</span> functions soon.
		</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idp1390361428"></a>5.4.4. Functions in Lua</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390361772"></a>Introduction</h4></div></div></div><p>You can write functions for the logic tier of <span class="application">Wolframe</span> with <span class="application">Lua</span>. <span class="application">Lua</span> is a scripting language designed, implemented, and maintained
		at PUC-Rio in Brazil by Roberto Ierusalimschy, Waldemar Celes and Luiz Henrique de Figueiredo
		(see <a class="ulink" href="http://www.lua.org/authors.html" target="_top">http://www.lua.org/authors.html</a>). A description of <span class="application">Lua</span> is not provided here.
		For an introduction into programming with <span class="application">Lua</span> see <a class="ulink" href="http://www.lua.org" target="_top">http://www.lua.org</a>. The official manual which is also available as book
		is very good. <span class="application">Wolframe</span> introduces some <span class="application">Lua</span> interfaces to access input and output and to execute functions.
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390403580"></a>Configuration</h4></div></div></div><p>For enabling <span class="application">Lua</span> you have to declare the loading of the module 'mod_command_lua'
		in the main section of the server configuration file.
		</p><pre class="programlisting">
		
    module mod_command_lua

		</pre><p>
		Each <span class="application">Lua</span> script referenced has to be declared in the <code class="code">Processor</code>
		section of the configuration with <code class="code">program &lt;sourcefile&gt;</code>.
		The script is recognized as <span class="application">Lua</span> script by the file extension ".lua".
		Files without this extension cannot be loaded as <span class="application">Lua</span> scripts.
		</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390407140"></a>Declaring functions</h4></div></div></div><p>For <span class="application">Lua</span> we do not have to declare anything in addition to the 
		<span class="application">Lua</span> script. If you configure a <span class="application">Lua</span>
		script as program, all global functions declared in this script are declared as global form
		functions. For avoiding name conflicts you should declare private functions
		of the script as <code class="code">local</code>.
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390409148"></a>Wolframe provider library</h4></div></div></div><p><span class="application">Wolframe</span> lets you access objects of the global context through
		a library called <code class="code">provider</code> offering the following functions:

		</p><div class="table"><a id="idp1390410164"></a><p class="title"><strong>Table 5.4. Method</strong></p><div class="table-contents"><table summary="Method" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Name</th><th>Parameter</th><th>Returns</th></tr></thead><tbody><tr><td>form</td><td>Name of the form</td><td>An instance of the form</td></tr><tr><td>type</td><td>Type name and initializer list</td><td>A constructor function to create a value instance of this type</td></tr><tr><td>formfunction</td><td>Name of the function</td><td>Form function defined in a <span class="application">Wolframe</span> program or module</td></tr><tr><td>document</td><td>Content string of the document to process</td><td>Returns an object of type "document" that allows the processing of the contents passed as argument.
						See description of type "document"</td></tr></tbody></table></div></div><p><br class="table-break" />
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390416076"></a>Using atomic data types</h4></div></div></div><p><span class="application">Wolframe</span> lets us extend the type system consisting 
		of Lua basic data types with our own. We can create atomic data types 
		defined in a module or in a DDL datatype definition program (.wnmp file).
		For this you call the <code class="code">type</code> method of the provider with 
		the type name as first argument plus the type initializer argument 
		list as additional parameters.
		The function returns a constructor function that can be called 
		with the initialization value as argument to get a
		value instance of this type. The name of the type can refer to 
		one of the following:

		</p><div class="table"><a id="idp1390417540"></a><p class="title"><strong>Table 5.5. List of Atomic Data Types</strong></p><div class="table-contents"><table summary="List of Atomic Data Types" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Class</th><th>Initializer Arguments</th><th>Description</th></tr></thead><tbody><tr><td>Custom data type</td><td>Custom Type Parameters</td><td>A custom data type defined in a module with arithmetic operators and methods</td></tr><tr><td>Normalization function</td><td>Dimension parameters</td><td>A type defined as normalization function in a module</td></tr><tr><td>DDL data type</td><td>(no arguments)</td><td>A normalizer defined as sequence of normalization functions in a .wnmp source file</td></tr><tr><td>Data type 'bignumber'</td><td>(no arguments)</td><td>Arbitrary precision number type</td></tr><tr><td>Data fype 'datetime'</td><td>(no arguments)</td><td>Data type representing date and time down to a granularity of microseconds</td></tr></tbody></table></div></div><p><br class="table-break" />
		</p><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390424996"></a>Data type 'datetime'</h5></div></div></div><p>
			The data type 'datetime' is used as interface for date time values.
			</p><div class="table"><a id="idp1390425524"></a><p class="title"><strong>Table 5.6. Methods of 'datetime'</strong></p><div class="table-contents"><table summary="Methods of 'datetime'" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Method Name</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td>&lt;constructor&gt;</td><td>year, month, day, hour, minute, second ,millisecond, microsecond</td><td>Creates a date and time value with a granularity down to microseconds</td></tr><tr><td>&lt;constructor&gt;</td><td>year, month, day, hour, minute, second ,millisecond</td><td>Creates a date and time value with a granularity down to milliseconds</td></tr><tr><td>&lt;constructor&gt;</td><td>year, month, day, hour, minute, second</td><td>Creates a date and time value</td></tr><tr><td>&lt;constructor&gt;</td><td>year, month, day</td><td>Creates a date value</td></tr><tr><td>year</td><td>(no arguments)</td><td>Return the value of the year</td></tr><tr><td>month</td><td>(no arguments)</td><td>Return the value of the month (1..12)</td></tr><tr><td>day</td><td>(no arguments)</td><td>Return the value of the day in the month (1..31)</td></tr><tr><td>hour</td><td>(no arguments)</td><td>Return the value of the hour in the day (0..23)</td></tr><tr><td>minute</td><td>(no arguments)</td><td>Return the value of the minute (0..59)</td></tr><tr><td>second</td><td>(no arguments)</td><td>Return the value of the second (0..63 : 59 + leap seconds)</td></tr><tr><td>millisecond</td><td>(no arguments)</td><td>Return the value of the millisecond (0..1023)</td></tr><tr><td>microsecond</td><td>(no arguments)</td><td>Return the value of the microsecond (0..1023)</td></tr><tr><td>__tostring</td><td>(no arguments)</td><td>Return the date as string in the format YYYYMMDD, YYYYMMDDhhmmss, YYYYMMDDhhmmssll or YYYYMMDDhhmmssllcc, depending on constructor used to create the date and time value.</td></tr></tbody></table></div></div><p><br class="table-break" />
		</p></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390438700"></a>Data Type 'bignumber'</h5></div></div></div><p>
			The data type 'bignumber' is used to reference fixed point BCD numbers with a precision of 32767 digits between -1E32767 and +1E32767.
			</p><div class="table"><a id="idp1390439300"></a><p class="title"><strong>Table 5.7. Methods of 'datetime'</strong></p><div class="table-contents"><table summary="Methods of 'datetime'" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Method name</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td>&lt;constructor&gt;</td><td>number value as string</td><td>Creates a bignumber from its string representation</td></tr><tr><td>&lt;constructor&gt;</td><td>number value</td><td>Creates a bignumber from a lua number value (double precision floating point number)</td></tr><tr><td>precision</td><td>(no arguments)</td><td>Return the number of significant digits in the number</td></tr><tr><td>scale</td><td>(no arguments)</td><td>Return the number of fractional digits (may be negative, may be bigger than precision)</td></tr><tr><td>digits</td><td>(no arguments)</td><td>Return the significant digits in the number</td></tr><tr><td>tonumber</td><td>(no arguments)</td><td>Return the number as lua number value (double precision floating point number) with possible lost of accurancy</td></tr><tr><td>__tostring</td><td>(no arguments)</td><td>Return the big number value as string (not normalized).</td></tr></tbody></table></div></div><p><br class="table-break" />
		</p></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390447500"></a>Filter interface iterators</h4></div></div></div><p>Lua provides an interface to the iterators internally used to couple 
		objects and functions. They are accessible as iterator function closure
		in <span class="application">Lua</span>. 
		The look similar to <span class="application">Lua</span> iterators but are not.
		You should not mix them with the standard <span class="application">Lua</span>
		iterators though the semantic is similar. Filter interface iterators do not
		return nodes of the tree as subtree objects but only the node data in the
		order of a pre-order traversal. You can recursively iterate on the tree
		and build the object during traversal if you want.
		The returned elements of the Filter interface iterators are tuples 
		with the following meaning:
	</p><div class="table"><a id="idp1390449580"></a><p class="title"><strong>Table 5.8. Filter interface iterator elements</strong></p><div class="table-contents"><table summary="Filter interface iterator elements" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Tuple First Element</th><th>Tuple Second Element</th><th>Description</th></tr></thead><tbody><tr><td>NIL/false</td><td>string/number</td><td>Open (tag is second element)</td></tr><tr><td>NIL/false</td><td>NIL/false</td><td>Close</td></tr><tr><td>Any non NIL/false</td><td>string/number</td><td>Attribute assignment (value is first, tag is second element)</td></tr><tr><td>string/number</td><td>NIL/false</td><td>Content value (value is first element)</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390455004"></a>Iterator library</h4></div></div></div><p><span class="application">Wolframe</span> lets you access filter interface
		iterators through a library called <code class="code">iterator</code> 
		offering the following functions:

		</p><div class="table"><a id="idp1390456020"></a><p class="title"><strong>Table 5.9. Method</strong></p><div class="table-contents"><table summary="Method" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Name</th><th>Parameter</th><th>Returns</th></tr></thead><tbody><tr><td>scope</td><td>serialization iterator (*)</td><td>An iterator restricted on the subnodes of the last visited node (**)</td></tr></tbody></table></div></div><p><br class="table-break" />
	</p><p>
		(*) See section "serialization iterator"
	</p><p>
		(**) If iterator.scope is called, all elements of the returned iterator has to be visited in order to continue 
		iteration with the origin iterator on which iterator.scope was called.
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390459724"></a>Global objects</h4></div></div></div><p>Besides the provider library <span class="application">Wolframe</span> defines the following objects global in the script execution context:
		</p><table border="0" summary="Simple list" class="simplelist"><tr><td>Name</td><td>Description</td></tr><tr><td>logger</td><td>object with methods for logging or debugging</td></tr></table><p>
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390461860"></a>Using forms</h4></div></div></div><p>The provider function <code class="code">provider.form( )</code> with the name of the form as string as 
		parameter returns an empty instance of a form. It takes the name of 
		the form as string argument. If you for example have a form configured 
		called "employee" and you want to create an employee object from 
		a <span class="application">Lua</span> table, you call
			</p><pre class="programlisting">
			
bcf = provider.form( "employee" )
bcf:fill( {surname='Hans', name='Muster', company='Wolframe'} )

			</pre><p>
		The first line creates the data form object.
		The second line fills the data into the data form object.
		</p><p>

		The form method <code class="code">fill</code> takes a second optional parameter. Passing "strict" as
		second parameter enforces a strict validation of the input against the form, meaning that
		attributes are checked to be attributes (when using XML serialization) and non optional elements are checked to be initialized.
		Passing "complete" as second parameter forces non optional elements to be checked for initialization
		but does not distinguish between attributes and content values. "relaxed" is the default and
		checks only the existence of filled-in values in the form.
		</p><p>
		Given the following validation form in simple form DDL syntax (see chapter "Forms"):
			</p><pre class="programlisting">
			
FORM Employee
	-root employee
{
    ID !@int                  ; Internal customer id (mandatory)
    name !string              ; Name of the customer (mandatory)
    company string            ; Company he is working for (optional)
}

			</pre><p>

		the call of <code class="code">fill</code> in the following piece of code will raise an error because some elements
		of the form ('ID' and 'name') are missing in the input:
			</p><pre class="programlisting">
			
bc = provider.form( "employee" ):fill( {company='Wolframe'}, "strict" )

			</pre><p>
		</p><p>
		To access the data in a form there are two form methods available.
		<code class="code">get()</code> returns a filter interface iterator on the form data.
		There is also a method <code class="code">value()</code> that returns the form data as
		<span class="application">Lua</span> data structure
		(a <span class="application">Lua</span> table or atomic value).
		</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390468948"></a>Form functions</h4></div></div></div><p>
		For calling transactions or built-in functions loaded as modules the <span class="application">Lua</span> layer defines the
		concept of functions. The provider function <code class="code">provider.formfunction</code> with the name of the function
		as argument returns a <span class="application">Lua</span> function. This function takes a table or a filter interface iterator as argument
		and returns a data form structure. The data in the returned form data structure can be
		accessed with <code class="code">get()</code> that returns a filter interface iterator on the content 
		and <code class="code">value()</code> that returns a <span class="application">Lua</span> table or 
		atomic value.
		</p><p>
		If you for example have a transaction called "insertEmployee" defined in a transaction description program
		file declared in the configuration called "insertEmployee" and you want to call it with the 'employee'
		object defined above as input, you do
			</p><pre class="programlisting">
			
f = provider.formfunction( "insertEmployee")
res = f ( {surname='Hans', name='Muster', company='Wolframe'} )
t = res:value()
output:print( t[ "id" ] )

			</pre><p>
		</p><p>
		The first line creates the function called "insertEmployee" as <span class="application">Lua</span> function.
		The second calls the transaction, the third creates a <span class="application">Lua</span> table out of the result
		and the fourth selects and prints the "id" element in the table.
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390474020"></a>List of <span class="application">Lua</span> objects</h4></div></div></div><p>This is a list of all objects and functions declared by <span class="application">Wolframe</span>:</p><div class="table"><a id="idp1390475220"></a><p class="title"><strong>Table 5.10. Data forms declared by DDL</strong></p><div class="table-contents"><table summary="Data forms declared by DDL" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>Method Name</th><th>Arguments</th><th>Returns</th><th>Description</th></tr></thead><tbody><tr><td>get</td><td> </td><td>filter interface iterator (*)</td><td>Returns a filter interface iterator on the form elements</td></tr><tr><td>value</td><td> </td><td><span class="application">Lua</span> table</td><td>Returns the contents of the data form as <span class="application">Lua</span> table or atomic value</td></tr><tr><td>__tostring</td><td> </td><td>string</td><td>String representation of form for debugging</td></tr><tr><td>name</td><td> </td><td>string</td><td>Returns the global name of the form.
					</td></tr><tr><td>fill</td><td><span class="application">Lua</span> table or 
					filter interface iterator (*), optional validation mode (**)</td><td>the filled form (for concatenation)</td><td>Validates input and fills the input data into the form.</td></tr></tbody></table></div></div><br class="table-break" /><p>
			(*) See section "filter interface iterator"
		</p><p>
			(**) "strict" (full validation), "complete" (only check for all non optional elements initialization) or "relaxed" (no validation except matching of input to elements)
		</p><div class="table"><a id="idp1390483868"></a><p class="title"><strong>Table 5.11. Data forms returned by functions</strong></p><div class="table-contents"><table summary="Data forms returned by functions" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Method Name</th><th>Returns</th><th>Description</th></tr></thead><tbody><tr><td>get</td><td>filter interface iterator (*)</td><td>Returns a filter interface iterator on the form elements</td></tr><tr><td>value</td><td><span class="application">Lua</span> table or atomic value</td><td>Returns the contents of the data form as <span class="application">Lua</span> table or atomic value</td></tr><tr><td>__tostring</td><td>string</td><td>String representation of form for debugging</td></tr></tbody></table></div></div><br class="table-break" /><p>
			(*) See section "filter interface iterator"
		</p><div class="table"><a id="idp1390489308"></a><p class="title"><strong>Table 5.12. Document</strong></p><div class="table-contents"><table summary="Document" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Method Name</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td>docformat</td><td> - </td><td>Returns the format of the document {'XML','JSON',etc..}</td></tr><tr><td>as</td><td>filter and/or document type table</td><td>Attaches a filter to the document to be used for processing</td></tr><tr><td>doctype</td><td> - </td><td>Returns the document type of the content. For retrieving the document type you have first to define a filter.</td></tr><tr><td>metadata</td><td> - </td><td>Returns the meta data structure of the content. For retrieving the document meta data you have first to define a filter.</td></tr><tr><td>value</td><td> - </td><td>Returns the contents of the document as <span class="application">Lua</span> table or atomic value. The method 'table' does the same but is considered to be deprecated.</td></tr><tr><td>table</td><td> - </td><td>Deprecated. Does return the same as the method 'value'</td></tr><tr><td>form</td><td> - </td><td>Returns the contents of the document as filled form instace</td></tr><tr><td>get</td><td> - </td><td>Returns a filter interface iterator (*) on the form elements</td></tr></tbody></table></div></div><br class="table-break" /><p>
			(*) See section "filter interface iterator"
		</p><div class="table"><a id="idp1390498628"></a><p class="title"><strong>Table 5.13. Logger functions</strong></p><div class="table-contents"><table summary="Logger functions" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Method Name</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td>logger.printc</td><td>arbitrary list of arguments</td><td>Print arguments to standard console output</td></tr><tr><td>logger.print</td><td>loglevel (string) plus arbitrary list of arguments</td><td>log argument list with defined log level</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idp1390502404"></a><p class="title"><strong>Table 5.14. Global functions</strong></p><div class="table-contents"><table summary="Global functions" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>Function Name</th><th>Arguments</th><th>Description</th></tr></thead><tbody><tr><td>provider.form</td><td>name of form (string)</td><td>Returns an empty data form object of the given type</td></tr><tr><td>provider.formfunction</td><td>name of function (string)</td><td>Returns a lua function to execute the <span class="application">Wolframe</span> function specified by name</td></tr><tr><td>provider.type</td><td>name of data type (string)</td><td>Returns a constructor function for the data type given by name. The name specifies either a custom data type or a normalization function as used in forms or one of the additional userdata types 'datetime' or 'bignumber'.</td></tr><tr><td>provider.document</td><td>Content string of the document to process</td><td>Returns an object of type "document" that allows the processing of the contents passed as argument.
						See description of type "document"</td></tr></tbody></table></div></div><br class="table-break" /><p>
			(*) See section "filter interface iterator "
		</p><p>
			(**) The filter interface iterator  of a defined scope must be consumed completely before consuming anything of the parent iterator.
			Otherwise it may lead to unexpected results because they share some part of the iterator state.
		</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a id="idp1390594068"></a>5.4.5. Functions in native C++</h3></div></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390594388"></a>Introduction</h4></div></div></div><p>You can write functions for the logic tier of <span class="application">Wolframe</span> with <span class="application">C++</span>. 
		Because native <span class="application">C++</span> is by nature a compiled and not an
		interpreted language, you have to build a module out of your function implementation.
		</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390583812"></a>Prerequisites</h4></div></div></div><p>For native <span class="application">C++</span> you need a <span class="application">C++</span>
	build system with compiler and linker or an integrated
	development environment for <span class="application">C++</span>. 
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390627500"></a>Declaring functions</h4></div></div></div><p>
		Form functions declared in <span class="application">C++</span> have two arguments. The output structure to fill
		is passed by reference as first and the input structure passed is by value.
		The input structure copy should not be modified by the callee. 
		This means in <span class="application">C++</span> that it is passed as const 
		reference.
		The function returns an <code class="code">int</code> that is <code class="code">0</code> on success 
		and any other value indicating an error code. The function may also throw a 
		runtime error exception in case of an error.
		The following example shows a function declaration. The function declaration
		is not complete because the input output structures need to be declared with some
		additional attributes needed for introspection. We will explain this in the following
		section.
	</p><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390629724"></a>Example Function Declaration</h5></div></div></div><p>The function takes a structure as input and writes the result into an
		output structure. In this example input and output type are the same, but this
		is not required. It's just the same here for simplicity. 
		</p><p>
		The elements of the function declaration are put into a structure with four elements.
		The <code class="code">typedef</code> for the InputType and OutputType structures is required,
		because the input and output types should be recogniceable without complicated 
		type introspection templates. (Template based introspection might cause spurious
		and hard to understand error messages when building the module). 
		</p><p>
		The function <code class="code">name</code> returns the name of the function that
		identifies the function in the Wolframe global scope.
		</p><p>
		The <code class="code">exec</code> function declared as static function with this signature refers to 
		the function implementation.</p><pre class="programlisting">
		
// ... PUT THE INCLUDES FOR THE "Customer" STRUCTURE DECLARATION HERE !

struct ProcessCustomer
{
    typedef Customer InputType; 
    typedef Customer OutputType; 
    static const char* name() {return "process_customer";}

    static int exec( const proc::ProcessorProvider* provider, InputType&amp; res, const OutputType&amp; param);
};


		</pre></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390633292"></a>Input/output data structures</h4></div></div></div><p>For defining input and output parameter structures in <span class="application">C++</span> you have to define the 
		structure and its serialization description. The serialization description is a static 
		function <code class="code">getStructDescription</code> without arguments returning a const structure that describes 
		what element names to bind to which structure elements.
	</p><p>
		The following example shows a form function parameter structure defined in <span class="application">C++</span>.
	</p><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390635268"></a>Header file</h5></div></div></div><p>Declares the structure and the serialization description of the structure.
		Structures may contain structures with their own serialization description.</p><pre class="programlisting">
		
#include "serialize/struct/structDescriptionBase.hpp"
#include &lt;string&gt;

namespace _Wolframe {
namespace example {

struct Customer
{
    int ID;                         // Internal customer id
    std::string name;               // Name of the customer
    std::string canonical_Name;     // Customer name in canonical form
    std::string country;            // Country
    std::string locality;           // Locality

    static const serialize::StructDescriptionBase* getStructDescription();
};

}}//namespace


		</pre></div><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390636932"></a>Source file</h5></div></div></div><p>Declares 'ID' as attribute and name, canonical_Name, country, locality as tags. 
		The '--' operator marks the end of attributes section and the start of content 
		section.</p><pre class="programlisting">
		
#include "serialize/struct/structDescription.hpp"

using namespace _Wolframe;

namespace {
struct CustomerDescription :public serialize::StructDescription&lt;Customer&gt;
{
    CustomerDescription()
    {
        (*this)
        ("ID", &amp;Customer::ID)
        --
        ("name", &amp;Customer::name)
        ("canonical_Name", &amp;Customer::canonical_Name)
        ("country", &amp;Customer::country)
        ("locality", &amp;Customer::locality)
        ;
    }
};

const serialize::StructDescriptionBase* Customer::getStructDescription()
{
    static CustomerDescription rt;
    return &amp;rt;
}


		</pre></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390638636"></a>Writing the module</h4></div></div></div><p>Now we have all pieces together to build a loadable
	<span class="application">Wolframe</span> module with our example <span class="application">C++</span>
	function. The following example shows what you have to
	declare in the main module source file.
	</p><div class="sect4"><div class="titlepage"><div><div><h5 class="title"><a id="idp1390639940"></a>Module declaration</h5></div></div></div><p>The module declaration needs to include <code class="code">appdevel.hpp</code> and
		of course all headers with the function and data structure declarations needed.
		The module starts with the header macro CPP_APPLICATION_FORM_FUNCTION_MODULE
		with a short description of the module.
		What follows are the function declarations declared with the macro
		CPP_APPLICATION_FORM_FUNCTION. This macro has the following arguments in
		this order:
		</p><table border="0" summary="Simple list" class="simplelist"><tr><td>Name</td><td>Description</td></tr><tr><td>NAME</td><td>identifier of the function</td></tr><tr><td>FUNCTION</td><td>implementation of the function</td></tr><tr><td>OUTPUT</td><td>output structure of the function</td></tr><tr><td>INPUT</td><td>input structure of the function</td></tr></table><p>
		The declaration list is closed with the parameterless footer macro
		CPP_APPLICATION_FORM_FUNCTION_MODULE_END.
		The following example shows an example module declaration:
		</p><pre class="programlisting">
		
#include "appDevel.hpp"
// ... PUT THE INCLUDES FOR THE "ProcessCustomer" FUNCTION DECLARATION HERE !

#include "customersFunction.hpp"

using namespace _Wolframe;

WF_MODULE_BEGIN( "ProcessCustomerFunction", "process customer function")
WF_FORM_FUNCTION("process_customer",ProcessCustomer::exec,Customer,Customer)
WF_MODULE_END


		</pre></div></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390644564"></a>Building the module</h4></div></div></div><p>For building the module we have to include all modules introduced here and
	to link at against the wolframe serialization library (wolframe_serialize)
	and the wolframe core library (wolframe).
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390645340"></a>Using the module</h4></div></div></div><p>The module built can be loaded as the other modules by declaring it in the wolframe
	LoadModules section of the configuration. Simply list it there with 
	<code class="code">module &lt;yourModuleName&gt;</code> with &lt;yourModuleName&gt; being the name
	or path to your module.
	</p></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a id="idp1390646548"></a>Validation issues</h4></div></div></div><p>
	<span class="application">C++</span> is a strongly typed language. This means that the
	input of a function and the output is already validated to be of a strictly
	defined structure. So a validation by passing the input through a form
	might not be needed anymore. The constructs used to describe structures of
	<span class="application">Wolframe</span>
	in native <span class="application">C++</span> are even capable of describing attributes
	like used in XML (section 'Input/Output Data Structures' above).
	See in the documentation of the standard command handler how validation can be
	skipped with the attribute <code class="code">SKIP</code>.
	</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="bk01ch05s03.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="bk01ch05.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="bk01ch05s05.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.3. Command handler </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5.5. Forms</td></tr></table></div></div></div>

<!-- Footer -->
<div xmlns="" class="wrapper row2">
	<div id="footer" class="clear">
		<div class="one_third first">
			<h2 class="footer_title">Documentation</h2>
			<nav class="footer_nav">
				<ul class="nospace">
					<li><a href="/documentation.html">User documentation</a></li>
					<li><a href="/documentation.html">Developer documentation</a></li>
				</ul>
			</nav>
		</div>

		<div class="one_third">
			<h2 class="footer_title">Downloads</h2>
			<nav class="footer_nav">
				<ul class="nospace">
					<li><a href="/downloads.html">Hosted on Github</a></li>
					<li><a href="/downloads.html">Packages on Sourceforge</a></li>
				</ul>
			</nav>
		</div>

		<div class="one_third">
			<h2 class="footer_title">Contact Us</h2>
			<nav class="footer_nav">
				<ul class="nospace">
					<li><strong>Email:</strong> <a href="/mailto:contact@wolframe.net">contact@wolframe.net</a></li>
					<li>
						<a id="googleplus-bttn" href="http://plus.google.com/116915890857205562872?prsrc=3" rel="publisher" target="_top" style="text-decoration:none;">
							<span>Google+</span></a>
						<a id="linkedin-bttn" href="#" target="_top" style="text-decoration:none;">
							<span>LinkedIn</span></a>
						<a id="twitter-bttn" href="http://twitter.com/ProjectWolframe" target="_top" style="text-decoration:none;">
							<span>twitter</span></a>
						<a id="rss-bttn" href="#" target="_top" style="text-decoration:none;">
							<span>rss</span></a>
					</li>
					<li>
						<a href="https://twitter.com/ProjectWolframe" class="twitter-follow-button" data-show-count="false" data-show-screen-name="false">Follow @ProjectWolframe</a>
						<div class="google-follow-button"><div class="g-follow" data-annotation="none" data-height="20" data-href="http://plus.google.com/116915890857205562872" data-rel="publisher"></div></div>
						<div class="google-plusone-button"><div class="g-plusone" data-href="http://www.wolframe.net" data-size="medium"></div></div>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>

<div xmlns="" class="wrapper row4">
	<div id="copyright" class="clear">
		<p class="fl_left">Copyright © 2014 - <a href="#">Project Wolframe</a> - All Rights Reserved</p>
		<p class="fl_right"><a href="/copyright.html">Copyrights and credits</a></p>
	</div>
</div>

<!-- Scripts -->
<script xmlns="" src="http://code.jquery.com/jquery-latest.min.js"></script>
<script xmlns="" src="http://code.jquery.com/ui/1.10.1/jquery-ui.min.js"></script>
<script xmlns="">window.jQuery || document.write('\x3Cscript src="/layout/scripts/jquery-latest.min.js"&gt;\x3C\/script&gt;\
\x3Cscript src="/layout/scripts/jquery-ui.min.js"&gt;\x3C\/script&gt;')</script>
<script xmlns="">jQuery(document).ready(function($){ $('img').removeAttr('width height'); });</script>
<script xmlns="" src="/layout/scripts/jquery-mobilemenu.min.js"></script>
<script xmlns="" src="/layout/scripts/custom.js"></script>

<!-- Google analytics tracking -->
<script xmlns="" type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-46433226-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- Tweeter follow script -->
<script xmlns="">
	!function( d, s, id )	{
		var js, fjs = d.getElementsByTagName(s)[0], p = /^http:/.test(d.location)?'http':'https';
		if( !d.getElementById( id ))	{
			js = d.createElement( s );
			js.id = id;
			js.src = p + '://platform.twitter.com/widgets.js';
			fjs.parentNode.insertBefore( js,fjs );
		}
	} ( document, 'script', 'twitter-wjs' );
</script>

<!-- Google +1, follow -->
<script xmlns="" type="text/javascript">
	window.___gcfg = {
		lang: 'en-US',
		parsetags: 'onload'
	};
	( function()	{
		var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
		po.src = 'https://apis.google.com/js/plusone.js';
		var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
	}) ();
</script>

</body></html>